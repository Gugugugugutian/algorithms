# Leetcode 1017

<https://leetcode.cn/problems/convert-to-base-2/?envType=daily-question&envId=2024-04-28>

## 方法一：模拟进位

同官方题解。

## 方法二：一个正数减一个负数

我们都知道用二进制表示一个数字时，第n位表示的数字是2的n次方。然而，当二进制变为“负二进制”时，我们发现第[1], [3], [5]...这样的奇数位所代表的数字变为了他们的相反数，而偶数位的意义恰好不变。

如果我们将这个数字看成一个正数减去一个负数，问题便会变得简单。以一个整数83（1010011）=64+16+2+1为例，我们列出他的二进制表示的含义：

|  | [0] | [1] | [2] | [3] | [4] | [5] | [6] |
|-----|-----|-----|-----|-----|-----|-----|-----|
| 值 |1|1|0|0|1|0|1|
| 大小 |1|2|4|8|16|32|64|

我们写出负二进制，他的意义如下所示：

|  | [0] | [1] | [2] | [3] | [4] | [5] | [6] |
|-----|-----|-----|-----|-----|-----|-----|-----|
| 值 |1|1|1|0|1|0|1|
| 大小 |1|-2|4|-8|16|-32|64|

可以看到，由于没有表示正整数2的位数，我们需要用正整数4和负整数-2组合达到这一目的。那么我们将这个数字看作85（1+4+16+64）与2的差如何呢？

按照这样的思路，我们把任意一个数字都可以看作是负二进制正数位的和，与一个数作减法运算得到的。使用这种分解方法后，对于任意一个数字，我们先找到那个正数acc：


~~~javascript
let acc = 0;
let exp4 = 1;
while(acc<n) {
    acc += Math.pow(4, exp4);
    exp4++;
}
~~~

找到的正数如下表所示。事实上，这个数字就是假设这种负二进制的正数位全为1，负数位全为0得到的，它恰好是这个位数能表示的最大负二进制数。

|  | [0] | [1] | [2] | [3] | [4] | [5] | [6] |
|-----|-----|-----|-----|-----|-----|-----|-----|
| 值 |1|none|1|none|1|none|1|
| 大小 |1|none|4|none|16|none|64|

这样，那个负数diff也不难找到了。

~~~javascript
let diff = acc - n;
~~~

需要注意的是，这个数的“负二进制正数位”不一定为0。我们不使用“83”这个例子，改用“80”便可发现这一点。由于80=64+16，所以在这个算法中会被当做85减去5处理，而减去5的操作便用到了diff的奇数位。

不过，我们可以用这样的规律解决：

（1）如果acc[i]===0，这一位就是diff[i]。

（2）如果acc[i]===1，这一位是diff[i]取反。

~~~javascript
while(acc>0) {
    if(acc&1 === 1){
        ans = '' + (~diff&1) + ans;
    }
    else {
        ans = '' + (diff&1) + ans;
    }
    acc >>= 1;
    diff >>= 1;
}
return ans;
~~~

最后，对于最低位做特殊处理，便可得到最终算法。

~~~javascript
/**
 * @param {number} n
 * @return {string}
 */
var baseNeg2 = function(n) {
    // 把结果看作一个正数减去一个负数
    let ans = '0';
    if(n%2!==0) {
        ans = '1';
        n--;
    }
    // 计算那个正数
    let acc = 0;
    let exp4 = 1;
    while(acc<n) {
        acc += Math.pow(4, exp4);
        exp4++;
    }
    // 计算那个负数
    let diff = acc - n;

    // 去除个位（最低位）以后：
    // （1）如果acc[i]===0，这一位就是diff[i]。
    // （2）如果acc[i]===1，这一位是diff[i]取反。
    acc >>= 1;
    diff >>= 1;
    while(acc>0) {
        if(acc&1 === 1){
            ans = '' + (~diff&1) + ans;
        }
        else {
            ans = '' + (diff&1) + ans;
        }
        acc >>= 1;
        diff >>= 1;
    }
    return ans;
};
~~~